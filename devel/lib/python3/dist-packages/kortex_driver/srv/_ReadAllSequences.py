# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from kortex_driver/ReadAllSequencesRequest.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import kortex_driver.msg

class ReadAllSequencesRequest(genpy.Message):
  _md5sum = "fa3403cd5897c9698bc0fdcb2a453fbc"
  _type = "kortex_driver/ReadAllSequencesRequest"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """Empty input

================================================================================
MSG: kortex_driver/Empty
"""
  __slots__ = ['input']
  _slot_types = ['kortex_driver/Empty']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       input

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(ReadAllSequencesRequest, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.input is None:
        self.input = kortex_driver.msg.Empty()
    else:
      self.input = kortex_driver.msg.Empty()

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      pass
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.input is None:
        self.input = kortex_driver.msg.Empty()
      end = 0
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      pass
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.input is None:
        self.input = kortex_driver.msg.Empty()
      end = 0
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from kortex_driver/ReadAllSequencesResponse.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import kortex_driver.msg

class ReadAllSequencesResponse(genpy.Message):
  _md5sum = "28a5ceb179f9bf733f0154f5ddc64e89"
  _type = "kortex_driver/ReadAllSequencesResponse"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """SequenceList output

================================================================================
MSG: kortex_driver/SequenceList

Sequence[] sequence_list
================================================================================
MSG: kortex_driver/Sequence

SequenceHandle handle
string name
string application_data
SequenceTask[] tasks
================================================================================
MSG: kortex_driver/SequenceHandle

uint32 identifier
uint32 permission
================================================================================
MSG: kortex_driver/SequenceTask

uint32 group_identifier
Action action
string application_data
================================================================================
MSG: kortex_driver/Action

ActionHandle handle
string name
string application_data
Action_action_parameters oneof_action_parameters
================================================================================
MSG: kortex_driver/ActionHandle

uint32 identifier
uint32 action_type
uint32 permission
================================================================================
MSG: kortex_driver/Action_action_parameters

TwistCommand[] send_twist_command
WrenchCommand[] send_wrench_command
Base_JointSpeeds[] send_joint_speeds
ConstrainedPose[] reach_pose
ConstrainedJointAngles[] reach_joint_angles
uint32[] toggle_admittance_mode
Snapshot[] snapshot
SwitchControlMapping[] switch_control_mapping
uint32[] navigate_joints
uint32[] navigate_mappings
ChangeTwist[] change_twist
ChangeJointSpeeds[] change_joint_speeds
ChangeWrench[] change_wrench
EmergencyStop[] apply_emergency_stop
Faults[] clear_faults
Delay[] delay
ActionHandle[] execute_action
GripperCommand[] send_gripper_command
GpioCommand[] send_gpio_command
Base_Stop[] stop_action
PreComputedJointTrajectory[] play_pre_computed_trajectory
SequenceHandle[] execute_sequence
WaypointList[] execute_waypoint_list
================================================================================
MSG: kortex_driver/TwistCommand

uint32 reference_frame
Twist twist
uint32 duration
================================================================================
MSG: kortex_driver/Twist

float32 linear_x
float32 linear_y
float32 linear_z
float32 angular_x
float32 angular_y
float32 angular_z
================================================================================
MSG: kortex_driver/WrenchCommand

uint32 reference_frame
uint32 mode
Wrench wrench
uint32 duration
================================================================================
MSG: kortex_driver/Wrench

float32 force_x
float32 force_y
float32 force_z
float32 torque_x
float32 torque_y
float32 torque_z
================================================================================
MSG: kortex_driver/Base_JointSpeeds

JointSpeed[] joint_speeds
uint32 duration
================================================================================
MSG: kortex_driver/JointSpeed

uint32 joint_identifier
float32 value
uint32 duration
================================================================================
MSG: kortex_driver/ConstrainedPose

Pose target_pose
CartesianTrajectoryConstraint constraint
================================================================================
MSG: kortex_driver/Pose

float32 x
float32 y
float32 z
float32 theta_x
float32 theta_y
float32 theta_z
================================================================================
MSG: kortex_driver/CartesianTrajectoryConstraint

CartesianTrajectoryConstraint_type oneof_type
================================================================================
MSG: kortex_driver/CartesianTrajectoryConstraint_type

CartesianSpeed[] speed
uint32[] duration
================================================================================
MSG: kortex_driver/CartesianSpeed

float32 translation
float32 orientation
================================================================================
MSG: kortex_driver/ConstrainedJointAngles

JointAngles joint_angles
JointTrajectoryConstraint constraint
================================================================================
MSG: kortex_driver/JointAngles

JointAngle[] joint_angles
================================================================================
MSG: kortex_driver/JointAngle

uint32 joint_identifier
float32 value
================================================================================
MSG: kortex_driver/JointTrajectoryConstraint

uint32 type
float32 value
================================================================================
MSG: kortex_driver/Snapshot

uint32 snapshot_type
================================================================================
MSG: kortex_driver/SwitchControlMapping

uint32 controller_identifier
MapGroupHandle map_group_handle
MapHandle map_handle
================================================================================
MSG: kortex_driver/MapGroupHandle

uint32 identifier
uint32 permission
================================================================================
MSG: kortex_driver/MapHandle

uint32 identifier
uint32 permission
================================================================================
MSG: kortex_driver/ChangeTwist

float32 linear
float32 angular
================================================================================
MSG: kortex_driver/ChangeJointSpeeds

Base_JointSpeeds joint_speeds
================================================================================
MSG: kortex_driver/ChangeWrench

float32 force
float32 torque
================================================================================
MSG: kortex_driver/EmergencyStop

================================================================================
MSG: kortex_driver/Faults

================================================================================
MSG: kortex_driver/Delay

uint32 duration
================================================================================
MSG: kortex_driver/GripperCommand

uint32 mode
Gripper gripper
uint32 duration
================================================================================
MSG: kortex_driver/Gripper

Finger[] finger
================================================================================
MSG: kortex_driver/Finger

uint32 finger_identifier
float32 value
================================================================================
MSG: kortex_driver/GpioCommand

uint32 port_identifier
uint32 pin_identifier
uint32 action
uint32 period
================================================================================
MSG: kortex_driver/Base_Stop

================================================================================
MSG: kortex_driver/PreComputedJointTrajectory

uint32 mode
PreComputedJointTrajectoryElement[] trajectory_elements
================================================================================
MSG: kortex_driver/PreComputedJointTrajectoryElement

float32[] joint_angles
float32[] joint_speeds
float32[] joint_accelerations
float32 time_from_start
================================================================================
MSG: kortex_driver/WaypointList

Waypoint[] waypoints
float32 duration
bool use_optimal_blending
================================================================================
MSG: kortex_driver/Waypoint

string name
Waypoint_type_of_waypoint oneof_type_of_waypoint
================================================================================
MSG: kortex_driver/Waypoint_type_of_waypoint

AngularWaypoint[] angular_waypoint
CartesianWaypoint[] cartesian_waypoint
================================================================================
MSG: kortex_driver/AngularWaypoint

float32[] angles
float32[] maximum_velocities
float32 duration
================================================================================
MSG: kortex_driver/CartesianWaypoint

Pose pose
uint32 reference_frame
float32 maximum_linear_velocity
float32 maximum_angular_velocity
float32 blending_radius"""
  __slots__ = ['output']
  _slot_types = ['kortex_driver/SequenceList']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       output

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(ReadAllSequencesResponse, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.output is None:
        self.output = kortex_driver.msg.SequenceList()
    else:
      self.output = kortex_driver.msg.SequenceList()

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      length = len(self.output.sequence_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.output.sequence_list:
        _v1 = val1.handle
        _x = _v1
        buff.write(_get_struct_2I().pack(_x.identifier, _x.permission))
        _x = val1.name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.application_data
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        length = len(val1.tasks)
        buff.write(_struct_I.pack(length))
        for val2 in val1.tasks:
          _x = val2.group_identifier
          buff.write(_get_struct_I().pack(_x))
          _v2 = val2.action
          _v3 = _v2.handle
          _x = _v3
          buff.write(_get_struct_3I().pack(_x.identifier, _x.action_type, _x.permission))
          _x = _v2.name
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
          _x = _v2.application_data
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
          _v4 = _v2.oneof_action_parameters
          length = len(_v4.send_twist_command)
          buff.write(_struct_I.pack(length))
          for val5 in _v4.send_twist_command:
            _x = val5.reference_frame
            buff.write(_get_struct_I().pack(_x))
            _v5 = val5.twist
            _x = _v5
            buff.write(_get_struct_6f().pack(_x.linear_x, _x.linear_y, _x.linear_z, _x.angular_x, _x.angular_y, _x.angular_z))
            _x = val5.duration
            buff.write(_get_struct_I().pack(_x))
          length = len(_v4.send_wrench_command)
          buff.write(_struct_I.pack(length))
          for val5 in _v4.send_wrench_command:
            _x = val5
            buff.write(_get_struct_2I().pack(_x.reference_frame, _x.mode))
            _v6 = val5.wrench
            _x = _v6
            buff.write(_get_struct_6f().pack(_x.force_x, _x.force_y, _x.force_z, _x.torque_x, _x.torque_y, _x.torque_z))
            _x = val5.duration
            buff.write(_get_struct_I().pack(_x))
          length = len(_v4.send_joint_speeds)
          buff.write(_struct_I.pack(length))
          for val5 in _v4.send_joint_speeds:
            length = len(val5.joint_speeds)
            buff.write(_struct_I.pack(length))
            for val6 in val5.joint_speeds:
              _x = val6
              buff.write(_get_struct_IfI().pack(_x.joint_identifier, _x.value, _x.duration))
            _x = val5.duration
            buff.write(_get_struct_I().pack(_x))
          length = len(_v4.reach_pose)
          buff.write(_struct_I.pack(length))
          for val5 in _v4.reach_pose:
            _v7 = val5.target_pose
            _x = _v7
            buff.write(_get_struct_6f().pack(_x.x, _x.y, _x.z, _x.theta_x, _x.theta_y, _x.theta_z))
            _v8 = val5.constraint
            _v9 = _v8.oneof_type
            length = len(_v9.speed)
            buff.write(_struct_I.pack(length))
            for val8 in _v9.speed:
              _x = val8
              buff.write(_get_struct_2f().pack(_x.translation, _x.orientation))
            length = len(_v9.duration)
            buff.write(_struct_I.pack(length))
            pattern = '<%sI'%length
            buff.write(struct.Struct(pattern).pack(*_v9.duration))
          length = len(_v4.reach_joint_angles)
          buff.write(_struct_I.pack(length))
          for val5 in _v4.reach_joint_angles:
            _v10 = val5.joint_angles
            length = len(_v10.joint_angles)
            buff.write(_struct_I.pack(length))
            for val7 in _v10.joint_angles:
              _x = val7
              buff.write(_get_struct_If().pack(_x.joint_identifier, _x.value))
            _v11 = val5.constraint
            _x = _v11
            buff.write(_get_struct_If().pack(_x.type, _x.value))
          length = len(_v4.toggle_admittance_mode)
          buff.write(_struct_I.pack(length))
          pattern = '<%sI'%length
          buff.write(struct.Struct(pattern).pack(*_v4.toggle_admittance_mode))
          length = len(_v4.snapshot)
          buff.write(_struct_I.pack(length))
          for val5 in _v4.snapshot:
            _x = val5.snapshot_type
            buff.write(_get_struct_I().pack(_x))
          length = len(_v4.switch_control_mapping)
          buff.write(_struct_I.pack(length))
          for val5 in _v4.switch_control_mapping:
            _x = val5.controller_identifier
            buff.write(_get_struct_I().pack(_x))
            _v12 = val5.map_group_handle
            _x = _v12
            buff.write(_get_struct_2I().pack(_x.identifier, _x.permission))
            _v13 = val5.map_handle
            _x = _v13
            buff.write(_get_struct_2I().pack(_x.identifier, _x.permission))
          length = len(_v4.navigate_joints)
          buff.write(_struct_I.pack(length))
          pattern = '<%sI'%length
          buff.write(struct.Struct(pattern).pack(*_v4.navigate_joints))
          length = len(_v4.navigate_mappings)
          buff.write(_struct_I.pack(length))
          pattern = '<%sI'%length
          buff.write(struct.Struct(pattern).pack(*_v4.navigate_mappings))
          length = len(_v4.change_twist)
          buff.write(_struct_I.pack(length))
          for val5 in _v4.change_twist:
            _x = val5
            buff.write(_get_struct_2f().pack(_x.linear, _x.angular))
          length = len(_v4.change_joint_speeds)
          buff.write(_struct_I.pack(length))
          for val5 in _v4.change_joint_speeds:
            _v14 = val5.joint_speeds
            length = len(_v14.joint_speeds)
            buff.write(_struct_I.pack(length))
            for val7 in _v14.joint_speeds:
              _x = val7
              buff.write(_get_struct_IfI().pack(_x.joint_identifier, _x.value, _x.duration))
            _x = _v14.duration
            buff.write(_get_struct_I().pack(_x))
          length = len(_v4.change_wrench)
          buff.write(_struct_I.pack(length))
          for val5 in _v4.change_wrench:
            _x = val5
            buff.write(_get_struct_2f().pack(_x.force, _x.torque))
          length = len(_v4.apply_emergency_stop)
          buff.write(_struct_I.pack(length))
          for val5 in _v4.apply_emergency_stop:
            pass
          length = len(_v4.clear_faults)
          buff.write(_struct_I.pack(length))
          for val5 in _v4.clear_faults:
            pass
          length = len(_v4.delay)
          buff.write(_struct_I.pack(length))
          for val5 in _v4.delay:
            _x = val5.duration
            buff.write(_get_struct_I().pack(_x))
          length = len(_v4.execute_action)
          buff.write(_struct_I.pack(length))
          for val5 in _v4.execute_action:
            _x = val5
            buff.write(_get_struct_3I().pack(_x.identifier, _x.action_type, _x.permission))
          length = len(_v4.send_gripper_command)
          buff.write(_struct_I.pack(length))
          for val5 in _v4.send_gripper_command:
            _x = val5.mode
            buff.write(_get_struct_I().pack(_x))
            _v15 = val5.gripper
            length = len(_v15.finger)
            buff.write(_struct_I.pack(length))
            for val7 in _v15.finger:
              _x = val7
              buff.write(_get_struct_If().pack(_x.finger_identifier, _x.value))
            _x = val5.duration
            buff.write(_get_struct_I().pack(_x))
          length = len(_v4.send_gpio_command)
          buff.write(_struct_I.pack(length))
          for val5 in _v4.send_gpio_command:
            _x = val5
            buff.write(_get_struct_4I().pack(_x.port_identifier, _x.pin_identifier, _x.action, _x.period))
          length = len(_v4.stop_action)
          buff.write(_struct_I.pack(length))
          for val5 in _v4.stop_action:
            pass
          length = len(_v4.play_pre_computed_trajectory)
          buff.write(_struct_I.pack(length))
          for val5 in _v4.play_pre_computed_trajectory:
            _x = val5.mode
            buff.write(_get_struct_I().pack(_x))
            length = len(val5.trajectory_elements)
            buff.write(_struct_I.pack(length))
            for val6 in val5.trajectory_elements:
              length = len(val6.joint_angles)
              buff.write(_struct_I.pack(length))
              pattern = '<%sf'%length
              buff.write(struct.Struct(pattern).pack(*val6.joint_angles))
              length = len(val6.joint_speeds)
              buff.write(_struct_I.pack(length))
              pattern = '<%sf'%length
              buff.write(struct.Struct(pattern).pack(*val6.joint_speeds))
              length = len(val6.joint_accelerations)
              buff.write(_struct_I.pack(length))
              pattern = '<%sf'%length
              buff.write(struct.Struct(pattern).pack(*val6.joint_accelerations))
              _x = val6.time_from_start
              buff.write(_get_struct_f().pack(_x))
          length = len(_v4.execute_sequence)
          buff.write(_struct_I.pack(length))
          for val5 in _v4.execute_sequence:
            _x = val5
            buff.write(_get_struct_2I().pack(_x.identifier, _x.permission))
          length = len(_v4.execute_waypoint_list)
          buff.write(_struct_I.pack(length))
          for val5 in _v4.execute_waypoint_list:
            length = len(val5.waypoints)
            buff.write(_struct_I.pack(length))
            for val6 in val5.waypoints:
              _x = val6.name
              length = len(_x)
              if python3 or type(_x) == unicode:
                _x = _x.encode('utf-8')
                length = len(_x)
              buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
              _v16 = val6.oneof_type_of_waypoint
              length = len(_v16.angular_waypoint)
              buff.write(_struct_I.pack(length))
              for val8 in _v16.angular_waypoint:
                length = len(val8.angles)
                buff.write(_struct_I.pack(length))
                pattern = '<%sf'%length
                buff.write(struct.Struct(pattern).pack(*val8.angles))
                length = len(val8.maximum_velocities)
                buff.write(_struct_I.pack(length))
                pattern = '<%sf'%length
                buff.write(struct.Struct(pattern).pack(*val8.maximum_velocities))
                _x = val8.duration
                buff.write(_get_struct_f().pack(_x))
              length = len(_v16.cartesian_waypoint)
              buff.write(_struct_I.pack(length))
              for val8 in _v16.cartesian_waypoint:
                _v17 = val8.pose
                _x = _v17
                buff.write(_get_struct_6f().pack(_x.x, _x.y, _x.z, _x.theta_x, _x.theta_y, _x.theta_z))
                _x = val8
                buff.write(_get_struct_I3f().pack(_x.reference_frame, _x.maximum_linear_velocity, _x.maximum_angular_velocity, _x.blending_radius))
            _x = val5
            buff.write(_get_struct_fB().pack(_x.duration, _x.use_optimal_blending))
          _x = val2.application_data
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.output is None:
        self.output = kortex_driver.msg.SequenceList()
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.output.sequence_list = []
      for i in range(0, length):
        val1 = kortex_driver.msg.Sequence()
        _v18 = val1.handle
        _x = _v18
        start = end
        end += 8
        (_x.identifier, _x.permission,) = _get_struct_2I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.name = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.name = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.application_data = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.application_data = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.tasks = []
        for i in range(0, length):
          val2 = kortex_driver.msg.SequenceTask()
          start = end
          end += 4
          (val2.group_identifier,) = _get_struct_I().unpack(str[start:end])
          _v19 = val2.action
          _v20 = _v19.handle
          _x = _v20
          start = end
          end += 12
          (_x.identifier, _x.action_type, _x.permission,) = _get_struct_3I().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            _v19.name = str[start:end].decode('utf-8', 'rosmsg')
          else:
            _v19.name = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            _v19.application_data = str[start:end].decode('utf-8', 'rosmsg')
          else:
            _v19.application_data = str[start:end]
          _v21 = _v19.oneof_action_parameters
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v21.send_twist_command = []
          for i in range(0, length):
            val5 = kortex_driver.msg.TwistCommand()
            start = end
            end += 4
            (val5.reference_frame,) = _get_struct_I().unpack(str[start:end])
            _v22 = val5.twist
            _x = _v22
            start = end
            end += 24
            (_x.linear_x, _x.linear_y, _x.linear_z, _x.angular_x, _x.angular_y, _x.angular_z,) = _get_struct_6f().unpack(str[start:end])
            start = end
            end += 4
            (val5.duration,) = _get_struct_I().unpack(str[start:end])
            _v21.send_twist_command.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v21.send_wrench_command = []
          for i in range(0, length):
            val5 = kortex_driver.msg.WrenchCommand()
            _x = val5
            start = end
            end += 8
            (_x.reference_frame, _x.mode,) = _get_struct_2I().unpack(str[start:end])
            _v23 = val5.wrench
            _x = _v23
            start = end
            end += 24
            (_x.force_x, _x.force_y, _x.force_z, _x.torque_x, _x.torque_y, _x.torque_z,) = _get_struct_6f().unpack(str[start:end])
            start = end
            end += 4
            (val5.duration,) = _get_struct_I().unpack(str[start:end])
            _v21.send_wrench_command.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v21.send_joint_speeds = []
          for i in range(0, length):
            val5 = kortex_driver.msg.Base_JointSpeeds()
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            val5.joint_speeds = []
            for i in range(0, length):
              val6 = kortex_driver.msg.JointSpeed()
              _x = val6
              start = end
              end += 12
              (_x.joint_identifier, _x.value, _x.duration,) = _get_struct_IfI().unpack(str[start:end])
              val5.joint_speeds.append(val6)
            start = end
            end += 4
            (val5.duration,) = _get_struct_I().unpack(str[start:end])
            _v21.send_joint_speeds.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v21.reach_pose = []
          for i in range(0, length):
            val5 = kortex_driver.msg.ConstrainedPose()
            _v24 = val5.target_pose
            _x = _v24
            start = end
            end += 24
            (_x.x, _x.y, _x.z, _x.theta_x, _x.theta_y, _x.theta_z,) = _get_struct_6f().unpack(str[start:end])
            _v25 = val5.constraint
            _v26 = _v25.oneof_type
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v26.speed = []
            for i in range(0, length):
              val8 = kortex_driver.msg.CartesianSpeed()
              _x = val8
              start = end
              end += 8
              (_x.translation, _x.orientation,) = _get_struct_2f().unpack(str[start:end])
              _v26.speed.append(val8)
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            pattern = '<%sI'%length
            start = end
            s = struct.Struct(pattern)
            end += s.size
            _v26.duration = s.unpack(str[start:end])
            _v21.reach_pose.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v21.reach_joint_angles = []
          for i in range(0, length):
            val5 = kortex_driver.msg.ConstrainedJointAngles()
            _v27 = val5.joint_angles
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v27.joint_angles = []
            for i in range(0, length):
              val7 = kortex_driver.msg.JointAngle()
              _x = val7
              start = end
              end += 8
              (_x.joint_identifier, _x.value,) = _get_struct_If().unpack(str[start:end])
              _v27.joint_angles.append(val7)
            _v28 = val5.constraint
            _x = _v28
            start = end
            end += 8
            (_x.type, _x.value,) = _get_struct_If().unpack(str[start:end])
            _v21.reach_joint_angles.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sI'%length
          start = end
          s = struct.Struct(pattern)
          end += s.size
          _v21.toggle_admittance_mode = s.unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v21.snapshot = []
          for i in range(0, length):
            val5 = kortex_driver.msg.Snapshot()
            start = end
            end += 4
            (val5.snapshot_type,) = _get_struct_I().unpack(str[start:end])
            _v21.snapshot.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v21.switch_control_mapping = []
          for i in range(0, length):
            val5 = kortex_driver.msg.SwitchControlMapping()
            start = end
            end += 4
            (val5.controller_identifier,) = _get_struct_I().unpack(str[start:end])
            _v29 = val5.map_group_handle
            _x = _v29
            start = end
            end += 8
            (_x.identifier, _x.permission,) = _get_struct_2I().unpack(str[start:end])
            _v30 = val5.map_handle
            _x = _v30
            start = end
            end += 8
            (_x.identifier, _x.permission,) = _get_struct_2I().unpack(str[start:end])
            _v21.switch_control_mapping.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sI'%length
          start = end
          s = struct.Struct(pattern)
          end += s.size
          _v21.navigate_joints = s.unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sI'%length
          start = end
          s = struct.Struct(pattern)
          end += s.size
          _v21.navigate_mappings = s.unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v21.change_twist = []
          for i in range(0, length):
            val5 = kortex_driver.msg.ChangeTwist()
            _x = val5
            start = end
            end += 8
            (_x.linear, _x.angular,) = _get_struct_2f().unpack(str[start:end])
            _v21.change_twist.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v21.change_joint_speeds = []
          for i in range(0, length):
            val5 = kortex_driver.msg.ChangeJointSpeeds()
            _v31 = val5.joint_speeds
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v31.joint_speeds = []
            for i in range(0, length):
              val7 = kortex_driver.msg.JointSpeed()
              _x = val7
              start = end
              end += 12
              (_x.joint_identifier, _x.value, _x.duration,) = _get_struct_IfI().unpack(str[start:end])
              _v31.joint_speeds.append(val7)
            start = end
            end += 4
            (_v31.duration,) = _get_struct_I().unpack(str[start:end])
            _v21.change_joint_speeds.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v21.change_wrench = []
          for i in range(0, length):
            val5 = kortex_driver.msg.ChangeWrench()
            _x = val5
            start = end
            end += 8
            (_x.force, _x.torque,) = _get_struct_2f().unpack(str[start:end])
            _v21.change_wrench.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v21.apply_emergency_stop = []
          for i in range(0, length):
            val5 = kortex_driver.msg.EmergencyStop()
            _v21.apply_emergency_stop.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v21.clear_faults = []
          for i in range(0, length):
            val5 = kortex_driver.msg.Faults()
            _v21.clear_faults.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v21.delay = []
          for i in range(0, length):
            val5 = kortex_driver.msg.Delay()
            start = end
            end += 4
            (val5.duration,) = _get_struct_I().unpack(str[start:end])
            _v21.delay.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v21.execute_action = []
          for i in range(0, length):
            val5 = kortex_driver.msg.ActionHandle()
            _x = val5
            start = end
            end += 12
            (_x.identifier, _x.action_type, _x.permission,) = _get_struct_3I().unpack(str[start:end])
            _v21.execute_action.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v21.send_gripper_command = []
          for i in range(0, length):
            val5 = kortex_driver.msg.GripperCommand()
            start = end
            end += 4
            (val5.mode,) = _get_struct_I().unpack(str[start:end])
            _v32 = val5.gripper
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v32.finger = []
            for i in range(0, length):
              val7 = kortex_driver.msg.Finger()
              _x = val7
              start = end
              end += 8
              (_x.finger_identifier, _x.value,) = _get_struct_If().unpack(str[start:end])
              _v32.finger.append(val7)
            start = end
            end += 4
            (val5.duration,) = _get_struct_I().unpack(str[start:end])
            _v21.send_gripper_command.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v21.send_gpio_command = []
          for i in range(0, length):
            val5 = kortex_driver.msg.GpioCommand()
            _x = val5
            start = end
            end += 16
            (_x.port_identifier, _x.pin_identifier, _x.action, _x.period,) = _get_struct_4I().unpack(str[start:end])
            _v21.send_gpio_command.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v21.stop_action = []
          for i in range(0, length):
            val5 = kortex_driver.msg.Base_Stop()
            _v21.stop_action.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v21.play_pre_computed_trajectory = []
          for i in range(0, length):
            val5 = kortex_driver.msg.PreComputedJointTrajectory()
            start = end
            end += 4
            (val5.mode,) = _get_struct_I().unpack(str[start:end])
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            val5.trajectory_elements = []
            for i in range(0, length):
              val6 = kortex_driver.msg.PreComputedJointTrajectoryElement()
              start = end
              end += 4
              (length,) = _struct_I.unpack(str[start:end])
              pattern = '<%sf'%length
              start = end
              s = struct.Struct(pattern)
              end += s.size
              val6.joint_angles = s.unpack(str[start:end])
              start = end
              end += 4
              (length,) = _struct_I.unpack(str[start:end])
              pattern = '<%sf'%length
              start = end
              s = struct.Struct(pattern)
              end += s.size
              val6.joint_speeds = s.unpack(str[start:end])
              start = end
              end += 4
              (length,) = _struct_I.unpack(str[start:end])
              pattern = '<%sf'%length
              start = end
              s = struct.Struct(pattern)
              end += s.size
              val6.joint_accelerations = s.unpack(str[start:end])
              start = end
              end += 4
              (val6.time_from_start,) = _get_struct_f().unpack(str[start:end])
              val5.trajectory_elements.append(val6)
            _v21.play_pre_computed_trajectory.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v21.execute_sequence = []
          for i in range(0, length):
            val5 = kortex_driver.msg.SequenceHandle()
            _x = val5
            start = end
            end += 8
            (_x.identifier, _x.permission,) = _get_struct_2I().unpack(str[start:end])
            _v21.execute_sequence.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v21.execute_waypoint_list = []
          for i in range(0, length):
            val5 = kortex_driver.msg.WaypointList()
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            val5.waypoints = []
            for i in range(0, length):
              val6 = kortex_driver.msg.Waypoint()
              start = end
              end += 4
              (length,) = _struct_I.unpack(str[start:end])
              start = end
              end += length
              if python3:
                val6.name = str[start:end].decode('utf-8', 'rosmsg')
              else:
                val6.name = str[start:end]
              _v33 = val6.oneof_type_of_waypoint
              start = end
              end += 4
              (length,) = _struct_I.unpack(str[start:end])
              _v33.angular_waypoint = []
              for i in range(0, length):
                val8 = kortex_driver.msg.AngularWaypoint()
                start = end
                end += 4
                (length,) = _struct_I.unpack(str[start:end])
                pattern = '<%sf'%length
                start = end
                s = struct.Struct(pattern)
                end += s.size
                val8.angles = s.unpack(str[start:end])
                start = end
                end += 4
                (length,) = _struct_I.unpack(str[start:end])
                pattern = '<%sf'%length
                start = end
                s = struct.Struct(pattern)
                end += s.size
                val8.maximum_velocities = s.unpack(str[start:end])
                start = end
                end += 4
                (val8.duration,) = _get_struct_f().unpack(str[start:end])
                _v33.angular_waypoint.append(val8)
              start = end
              end += 4
              (length,) = _struct_I.unpack(str[start:end])
              _v33.cartesian_waypoint = []
              for i in range(0, length):
                val8 = kortex_driver.msg.CartesianWaypoint()
                _v34 = val8.pose
                _x = _v34
                start = end
                end += 24
                (_x.x, _x.y, _x.z, _x.theta_x, _x.theta_y, _x.theta_z,) = _get_struct_6f().unpack(str[start:end])
                _x = val8
                start = end
                end += 16
                (_x.reference_frame, _x.maximum_linear_velocity, _x.maximum_angular_velocity, _x.blending_radius,) = _get_struct_I3f().unpack(str[start:end])
                _v33.cartesian_waypoint.append(val8)
              val5.waypoints.append(val6)
            _x = val5
            start = end
            end += 5
            (_x.duration, _x.use_optimal_blending,) = _get_struct_fB().unpack(str[start:end])
            val5.use_optimal_blending = bool(val5.use_optimal_blending)
            _v21.execute_waypoint_list.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.application_data = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val2.application_data = str[start:end]
          val1.tasks.append(val2)
        self.output.sequence_list.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      length = len(self.output.sequence_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.output.sequence_list:
        _v35 = val1.handle
        _x = _v35
        buff.write(_get_struct_2I().pack(_x.identifier, _x.permission))
        _x = val1.name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.application_data
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        length = len(val1.tasks)
        buff.write(_struct_I.pack(length))
        for val2 in val1.tasks:
          _x = val2.group_identifier
          buff.write(_get_struct_I().pack(_x))
          _v36 = val2.action
          _v37 = _v36.handle
          _x = _v37
          buff.write(_get_struct_3I().pack(_x.identifier, _x.action_type, _x.permission))
          _x = _v36.name
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
          _x = _v36.application_data
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
          _v38 = _v36.oneof_action_parameters
          length = len(_v38.send_twist_command)
          buff.write(_struct_I.pack(length))
          for val5 in _v38.send_twist_command:
            _x = val5.reference_frame
            buff.write(_get_struct_I().pack(_x))
            _v39 = val5.twist
            _x = _v39
            buff.write(_get_struct_6f().pack(_x.linear_x, _x.linear_y, _x.linear_z, _x.angular_x, _x.angular_y, _x.angular_z))
            _x = val5.duration
            buff.write(_get_struct_I().pack(_x))
          length = len(_v38.send_wrench_command)
          buff.write(_struct_I.pack(length))
          for val5 in _v38.send_wrench_command:
            _x = val5
            buff.write(_get_struct_2I().pack(_x.reference_frame, _x.mode))
            _v40 = val5.wrench
            _x = _v40
            buff.write(_get_struct_6f().pack(_x.force_x, _x.force_y, _x.force_z, _x.torque_x, _x.torque_y, _x.torque_z))
            _x = val5.duration
            buff.write(_get_struct_I().pack(_x))
          length = len(_v38.send_joint_speeds)
          buff.write(_struct_I.pack(length))
          for val5 in _v38.send_joint_speeds:
            length = len(val5.joint_speeds)
            buff.write(_struct_I.pack(length))
            for val6 in val5.joint_speeds:
              _x = val6
              buff.write(_get_struct_IfI().pack(_x.joint_identifier, _x.value, _x.duration))
            _x = val5.duration
            buff.write(_get_struct_I().pack(_x))
          length = len(_v38.reach_pose)
          buff.write(_struct_I.pack(length))
          for val5 in _v38.reach_pose:
            _v41 = val5.target_pose
            _x = _v41
            buff.write(_get_struct_6f().pack(_x.x, _x.y, _x.z, _x.theta_x, _x.theta_y, _x.theta_z))
            _v42 = val5.constraint
            _v43 = _v42.oneof_type
            length = len(_v43.speed)
            buff.write(_struct_I.pack(length))
            for val8 in _v43.speed:
              _x = val8
              buff.write(_get_struct_2f().pack(_x.translation, _x.orientation))
            length = len(_v43.duration)
            buff.write(_struct_I.pack(length))
            pattern = '<%sI'%length
            buff.write(_v43.duration.tostring())
          length = len(_v38.reach_joint_angles)
          buff.write(_struct_I.pack(length))
          for val5 in _v38.reach_joint_angles:
            _v44 = val5.joint_angles
            length = len(_v44.joint_angles)
            buff.write(_struct_I.pack(length))
            for val7 in _v44.joint_angles:
              _x = val7
              buff.write(_get_struct_If().pack(_x.joint_identifier, _x.value))
            _v45 = val5.constraint
            _x = _v45
            buff.write(_get_struct_If().pack(_x.type, _x.value))
          length = len(_v38.toggle_admittance_mode)
          buff.write(_struct_I.pack(length))
          pattern = '<%sI'%length
          buff.write(_v38.toggle_admittance_mode.tostring())
          length = len(_v38.snapshot)
          buff.write(_struct_I.pack(length))
          for val5 in _v38.snapshot:
            _x = val5.snapshot_type
            buff.write(_get_struct_I().pack(_x))
          length = len(_v38.switch_control_mapping)
          buff.write(_struct_I.pack(length))
          for val5 in _v38.switch_control_mapping:
            _x = val5.controller_identifier
            buff.write(_get_struct_I().pack(_x))
            _v46 = val5.map_group_handle
            _x = _v46
            buff.write(_get_struct_2I().pack(_x.identifier, _x.permission))
            _v47 = val5.map_handle
            _x = _v47
            buff.write(_get_struct_2I().pack(_x.identifier, _x.permission))
          length = len(_v38.navigate_joints)
          buff.write(_struct_I.pack(length))
          pattern = '<%sI'%length
          buff.write(_v38.navigate_joints.tostring())
          length = len(_v38.navigate_mappings)
          buff.write(_struct_I.pack(length))
          pattern = '<%sI'%length
          buff.write(_v38.navigate_mappings.tostring())
          length = len(_v38.change_twist)
          buff.write(_struct_I.pack(length))
          for val5 in _v38.change_twist:
            _x = val5
            buff.write(_get_struct_2f().pack(_x.linear, _x.angular))
          length = len(_v38.change_joint_speeds)
          buff.write(_struct_I.pack(length))
          for val5 in _v38.change_joint_speeds:
            _v48 = val5.joint_speeds
            length = len(_v48.joint_speeds)
            buff.write(_struct_I.pack(length))
            for val7 in _v48.joint_speeds:
              _x = val7
              buff.write(_get_struct_IfI().pack(_x.joint_identifier, _x.value, _x.duration))
            _x = _v48.duration
            buff.write(_get_struct_I().pack(_x))
          length = len(_v38.change_wrench)
          buff.write(_struct_I.pack(length))
          for val5 in _v38.change_wrench:
            _x = val5
            buff.write(_get_struct_2f().pack(_x.force, _x.torque))
          length = len(_v38.apply_emergency_stop)
          buff.write(_struct_I.pack(length))
          for val5 in _v38.apply_emergency_stop:
            pass
          length = len(_v38.clear_faults)
          buff.write(_struct_I.pack(length))
          for val5 in _v38.clear_faults:
            pass
          length = len(_v38.delay)
          buff.write(_struct_I.pack(length))
          for val5 in _v38.delay:
            _x = val5.duration
            buff.write(_get_struct_I().pack(_x))
          length = len(_v38.execute_action)
          buff.write(_struct_I.pack(length))
          for val5 in _v38.execute_action:
            _x = val5
            buff.write(_get_struct_3I().pack(_x.identifier, _x.action_type, _x.permission))
          length = len(_v38.send_gripper_command)
          buff.write(_struct_I.pack(length))
          for val5 in _v38.send_gripper_command:
            _x = val5.mode
            buff.write(_get_struct_I().pack(_x))
            _v49 = val5.gripper
            length = len(_v49.finger)
            buff.write(_struct_I.pack(length))
            for val7 in _v49.finger:
              _x = val7
              buff.write(_get_struct_If().pack(_x.finger_identifier, _x.value))
            _x = val5.duration
            buff.write(_get_struct_I().pack(_x))
          length = len(_v38.send_gpio_command)
          buff.write(_struct_I.pack(length))
          for val5 in _v38.send_gpio_command:
            _x = val5
            buff.write(_get_struct_4I().pack(_x.port_identifier, _x.pin_identifier, _x.action, _x.period))
          length = len(_v38.stop_action)
          buff.write(_struct_I.pack(length))
          for val5 in _v38.stop_action:
            pass
          length = len(_v38.play_pre_computed_trajectory)
          buff.write(_struct_I.pack(length))
          for val5 in _v38.play_pre_computed_trajectory:
            _x = val5.mode
            buff.write(_get_struct_I().pack(_x))
            length = len(val5.trajectory_elements)
            buff.write(_struct_I.pack(length))
            for val6 in val5.trajectory_elements:
              length = len(val6.joint_angles)
              buff.write(_struct_I.pack(length))
              pattern = '<%sf'%length
              buff.write(val6.joint_angles.tostring())
              length = len(val6.joint_speeds)
              buff.write(_struct_I.pack(length))
              pattern = '<%sf'%length
              buff.write(val6.joint_speeds.tostring())
              length = len(val6.joint_accelerations)
              buff.write(_struct_I.pack(length))
              pattern = '<%sf'%length
              buff.write(val6.joint_accelerations.tostring())
              _x = val6.time_from_start
              buff.write(_get_struct_f().pack(_x))
          length = len(_v38.execute_sequence)
          buff.write(_struct_I.pack(length))
          for val5 in _v38.execute_sequence:
            _x = val5
            buff.write(_get_struct_2I().pack(_x.identifier, _x.permission))
          length = len(_v38.execute_waypoint_list)
          buff.write(_struct_I.pack(length))
          for val5 in _v38.execute_waypoint_list:
            length = len(val5.waypoints)
            buff.write(_struct_I.pack(length))
            for val6 in val5.waypoints:
              _x = val6.name
              length = len(_x)
              if python3 or type(_x) == unicode:
                _x = _x.encode('utf-8')
                length = len(_x)
              buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
              _v50 = val6.oneof_type_of_waypoint
              length = len(_v50.angular_waypoint)
              buff.write(_struct_I.pack(length))
              for val8 in _v50.angular_waypoint:
                length = len(val8.angles)
                buff.write(_struct_I.pack(length))
                pattern = '<%sf'%length
                buff.write(val8.angles.tostring())
                length = len(val8.maximum_velocities)
                buff.write(_struct_I.pack(length))
                pattern = '<%sf'%length
                buff.write(val8.maximum_velocities.tostring())
                _x = val8.duration
                buff.write(_get_struct_f().pack(_x))
              length = len(_v50.cartesian_waypoint)
              buff.write(_struct_I.pack(length))
              for val8 in _v50.cartesian_waypoint:
                _v51 = val8.pose
                _x = _v51
                buff.write(_get_struct_6f().pack(_x.x, _x.y, _x.z, _x.theta_x, _x.theta_y, _x.theta_z))
                _x = val8
                buff.write(_get_struct_I3f().pack(_x.reference_frame, _x.maximum_linear_velocity, _x.maximum_angular_velocity, _x.blending_radius))
            _x = val5
            buff.write(_get_struct_fB().pack(_x.duration, _x.use_optimal_blending))
          _x = val2.application_data
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.output is None:
        self.output = kortex_driver.msg.SequenceList()
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.output.sequence_list = []
      for i in range(0, length):
        val1 = kortex_driver.msg.Sequence()
        _v52 = val1.handle
        _x = _v52
        start = end
        end += 8
        (_x.identifier, _x.permission,) = _get_struct_2I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.name = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.name = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.application_data = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.application_data = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.tasks = []
        for i in range(0, length):
          val2 = kortex_driver.msg.SequenceTask()
          start = end
          end += 4
          (val2.group_identifier,) = _get_struct_I().unpack(str[start:end])
          _v53 = val2.action
          _v54 = _v53.handle
          _x = _v54
          start = end
          end += 12
          (_x.identifier, _x.action_type, _x.permission,) = _get_struct_3I().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            _v53.name = str[start:end].decode('utf-8', 'rosmsg')
          else:
            _v53.name = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            _v53.application_data = str[start:end].decode('utf-8', 'rosmsg')
          else:
            _v53.application_data = str[start:end]
          _v55 = _v53.oneof_action_parameters
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v55.send_twist_command = []
          for i in range(0, length):
            val5 = kortex_driver.msg.TwistCommand()
            start = end
            end += 4
            (val5.reference_frame,) = _get_struct_I().unpack(str[start:end])
            _v56 = val5.twist
            _x = _v56
            start = end
            end += 24
            (_x.linear_x, _x.linear_y, _x.linear_z, _x.angular_x, _x.angular_y, _x.angular_z,) = _get_struct_6f().unpack(str[start:end])
            start = end
            end += 4
            (val5.duration,) = _get_struct_I().unpack(str[start:end])
            _v55.send_twist_command.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v55.send_wrench_command = []
          for i in range(0, length):
            val5 = kortex_driver.msg.WrenchCommand()
            _x = val5
            start = end
            end += 8
            (_x.reference_frame, _x.mode,) = _get_struct_2I().unpack(str[start:end])
            _v57 = val5.wrench
            _x = _v57
            start = end
            end += 24
            (_x.force_x, _x.force_y, _x.force_z, _x.torque_x, _x.torque_y, _x.torque_z,) = _get_struct_6f().unpack(str[start:end])
            start = end
            end += 4
            (val5.duration,) = _get_struct_I().unpack(str[start:end])
            _v55.send_wrench_command.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v55.send_joint_speeds = []
          for i in range(0, length):
            val5 = kortex_driver.msg.Base_JointSpeeds()
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            val5.joint_speeds = []
            for i in range(0, length):
              val6 = kortex_driver.msg.JointSpeed()
              _x = val6
              start = end
              end += 12
              (_x.joint_identifier, _x.value, _x.duration,) = _get_struct_IfI().unpack(str[start:end])
              val5.joint_speeds.append(val6)
            start = end
            end += 4
            (val5.duration,) = _get_struct_I().unpack(str[start:end])
            _v55.send_joint_speeds.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v55.reach_pose = []
          for i in range(0, length):
            val5 = kortex_driver.msg.ConstrainedPose()
            _v58 = val5.target_pose
            _x = _v58
            start = end
            end += 24
            (_x.x, _x.y, _x.z, _x.theta_x, _x.theta_y, _x.theta_z,) = _get_struct_6f().unpack(str[start:end])
            _v59 = val5.constraint
            _v60 = _v59.oneof_type
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v60.speed = []
            for i in range(0, length):
              val8 = kortex_driver.msg.CartesianSpeed()
              _x = val8
              start = end
              end += 8
              (_x.translation, _x.orientation,) = _get_struct_2f().unpack(str[start:end])
              _v60.speed.append(val8)
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            pattern = '<%sI'%length
            start = end
            s = struct.Struct(pattern)
            end += s.size
            _v60.duration = numpy.frombuffer(str[start:end], dtype=numpy.uint32, count=length)
            _v55.reach_pose.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v55.reach_joint_angles = []
          for i in range(0, length):
            val5 = kortex_driver.msg.ConstrainedJointAngles()
            _v61 = val5.joint_angles
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v61.joint_angles = []
            for i in range(0, length):
              val7 = kortex_driver.msg.JointAngle()
              _x = val7
              start = end
              end += 8
              (_x.joint_identifier, _x.value,) = _get_struct_If().unpack(str[start:end])
              _v61.joint_angles.append(val7)
            _v62 = val5.constraint
            _x = _v62
            start = end
            end += 8
            (_x.type, _x.value,) = _get_struct_If().unpack(str[start:end])
            _v55.reach_joint_angles.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sI'%length
          start = end
          s = struct.Struct(pattern)
          end += s.size
          _v55.toggle_admittance_mode = numpy.frombuffer(str[start:end], dtype=numpy.uint32, count=length)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v55.snapshot = []
          for i in range(0, length):
            val5 = kortex_driver.msg.Snapshot()
            start = end
            end += 4
            (val5.snapshot_type,) = _get_struct_I().unpack(str[start:end])
            _v55.snapshot.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v55.switch_control_mapping = []
          for i in range(0, length):
            val5 = kortex_driver.msg.SwitchControlMapping()
            start = end
            end += 4
            (val5.controller_identifier,) = _get_struct_I().unpack(str[start:end])
            _v63 = val5.map_group_handle
            _x = _v63
            start = end
            end += 8
            (_x.identifier, _x.permission,) = _get_struct_2I().unpack(str[start:end])
            _v64 = val5.map_handle
            _x = _v64
            start = end
            end += 8
            (_x.identifier, _x.permission,) = _get_struct_2I().unpack(str[start:end])
            _v55.switch_control_mapping.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sI'%length
          start = end
          s = struct.Struct(pattern)
          end += s.size
          _v55.navigate_joints = numpy.frombuffer(str[start:end], dtype=numpy.uint32, count=length)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sI'%length
          start = end
          s = struct.Struct(pattern)
          end += s.size
          _v55.navigate_mappings = numpy.frombuffer(str[start:end], dtype=numpy.uint32, count=length)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v55.change_twist = []
          for i in range(0, length):
            val5 = kortex_driver.msg.ChangeTwist()
            _x = val5
            start = end
            end += 8
            (_x.linear, _x.angular,) = _get_struct_2f().unpack(str[start:end])
            _v55.change_twist.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v55.change_joint_speeds = []
          for i in range(0, length):
            val5 = kortex_driver.msg.ChangeJointSpeeds()
            _v65 = val5.joint_speeds
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v65.joint_speeds = []
            for i in range(0, length):
              val7 = kortex_driver.msg.JointSpeed()
              _x = val7
              start = end
              end += 12
              (_x.joint_identifier, _x.value, _x.duration,) = _get_struct_IfI().unpack(str[start:end])
              _v65.joint_speeds.append(val7)
            start = end
            end += 4
            (_v65.duration,) = _get_struct_I().unpack(str[start:end])
            _v55.change_joint_speeds.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v55.change_wrench = []
          for i in range(0, length):
            val5 = kortex_driver.msg.ChangeWrench()
            _x = val5
            start = end
            end += 8
            (_x.force, _x.torque,) = _get_struct_2f().unpack(str[start:end])
            _v55.change_wrench.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v55.apply_emergency_stop = []
          for i in range(0, length):
            val5 = kortex_driver.msg.EmergencyStop()
            _v55.apply_emergency_stop.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v55.clear_faults = []
          for i in range(0, length):
            val5 = kortex_driver.msg.Faults()
            _v55.clear_faults.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v55.delay = []
          for i in range(0, length):
            val5 = kortex_driver.msg.Delay()
            start = end
            end += 4
            (val5.duration,) = _get_struct_I().unpack(str[start:end])
            _v55.delay.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v55.execute_action = []
          for i in range(0, length):
            val5 = kortex_driver.msg.ActionHandle()
            _x = val5
            start = end
            end += 12
            (_x.identifier, _x.action_type, _x.permission,) = _get_struct_3I().unpack(str[start:end])
            _v55.execute_action.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v55.send_gripper_command = []
          for i in range(0, length):
            val5 = kortex_driver.msg.GripperCommand()
            start = end
            end += 4
            (val5.mode,) = _get_struct_I().unpack(str[start:end])
            _v66 = val5.gripper
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v66.finger = []
            for i in range(0, length):
              val7 = kortex_driver.msg.Finger()
              _x = val7
              start = end
              end += 8
              (_x.finger_identifier, _x.value,) = _get_struct_If().unpack(str[start:end])
              _v66.finger.append(val7)
            start = end
            end += 4
            (val5.duration,) = _get_struct_I().unpack(str[start:end])
            _v55.send_gripper_command.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v55.send_gpio_command = []
          for i in range(0, length):
            val5 = kortex_driver.msg.GpioCommand()
            _x = val5
            start = end
            end += 16
            (_x.port_identifier, _x.pin_identifier, _x.action, _x.period,) = _get_struct_4I().unpack(str[start:end])
            _v55.send_gpio_command.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v55.stop_action = []
          for i in range(0, length):
            val5 = kortex_driver.msg.Base_Stop()
            _v55.stop_action.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v55.play_pre_computed_trajectory = []
          for i in range(0, length):
            val5 = kortex_driver.msg.PreComputedJointTrajectory()
            start = end
            end += 4
            (val5.mode,) = _get_struct_I().unpack(str[start:end])
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            val5.trajectory_elements = []
            for i in range(0, length):
              val6 = kortex_driver.msg.PreComputedJointTrajectoryElement()
              start = end
              end += 4
              (length,) = _struct_I.unpack(str[start:end])
              pattern = '<%sf'%length
              start = end
              s = struct.Struct(pattern)
              end += s.size
              val6.joint_angles = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
              start = end
              end += 4
              (length,) = _struct_I.unpack(str[start:end])
              pattern = '<%sf'%length
              start = end
              s = struct.Struct(pattern)
              end += s.size
              val6.joint_speeds = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
              start = end
              end += 4
              (length,) = _struct_I.unpack(str[start:end])
              pattern = '<%sf'%length
              start = end
              s = struct.Struct(pattern)
              end += s.size
              val6.joint_accelerations = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
              start = end
              end += 4
              (val6.time_from_start,) = _get_struct_f().unpack(str[start:end])
              val5.trajectory_elements.append(val6)
            _v55.play_pre_computed_trajectory.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v55.execute_sequence = []
          for i in range(0, length):
            val5 = kortex_driver.msg.SequenceHandle()
            _x = val5
            start = end
            end += 8
            (_x.identifier, _x.permission,) = _get_struct_2I().unpack(str[start:end])
            _v55.execute_sequence.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v55.execute_waypoint_list = []
          for i in range(0, length):
            val5 = kortex_driver.msg.WaypointList()
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            val5.waypoints = []
            for i in range(0, length):
              val6 = kortex_driver.msg.Waypoint()
              start = end
              end += 4
              (length,) = _struct_I.unpack(str[start:end])
              start = end
              end += length
              if python3:
                val6.name = str[start:end].decode('utf-8', 'rosmsg')
              else:
                val6.name = str[start:end]
              _v67 = val6.oneof_type_of_waypoint
              start = end
              end += 4
              (length,) = _struct_I.unpack(str[start:end])
              _v67.angular_waypoint = []
              for i in range(0, length):
                val8 = kortex_driver.msg.AngularWaypoint()
                start = end
                end += 4
                (length,) = _struct_I.unpack(str[start:end])
                pattern = '<%sf'%length
                start = end
                s = struct.Struct(pattern)
                end += s.size
                val8.angles = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
                start = end
                end += 4
                (length,) = _struct_I.unpack(str[start:end])
                pattern = '<%sf'%length
                start = end
                s = struct.Struct(pattern)
                end += s.size
                val8.maximum_velocities = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
                start = end
                end += 4
                (val8.duration,) = _get_struct_f().unpack(str[start:end])
                _v67.angular_waypoint.append(val8)
              start = end
              end += 4
              (length,) = _struct_I.unpack(str[start:end])
              _v67.cartesian_waypoint = []
              for i in range(0, length):
                val8 = kortex_driver.msg.CartesianWaypoint()
                _v68 = val8.pose
                _x = _v68
                start = end
                end += 24
                (_x.x, _x.y, _x.z, _x.theta_x, _x.theta_y, _x.theta_z,) = _get_struct_6f().unpack(str[start:end])
                _x = val8
                start = end
                end += 16
                (_x.reference_frame, _x.maximum_linear_velocity, _x.maximum_angular_velocity, _x.blending_radius,) = _get_struct_I3f().unpack(str[start:end])
                _v67.cartesian_waypoint.append(val8)
              val5.waypoints.append(val6)
            _x = val5
            start = end
            end += 5
            (_x.duration, _x.use_optimal_blending,) = _get_struct_fB().unpack(str[start:end])
            val5.use_optimal_blending = bool(val5.use_optimal_blending)
            _v55.execute_waypoint_list.append(val5)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.application_data = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val2.application_data = str[start:end]
          val1.tasks.append(val2)
        self.output.sequence_list.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_2I = None
def _get_struct_2I():
    global _struct_2I
    if _struct_2I is None:
        _struct_2I = struct.Struct("<2I")
    return _struct_2I
_struct_2f = None
def _get_struct_2f():
    global _struct_2f
    if _struct_2f is None:
        _struct_2f = struct.Struct("<2f")
    return _struct_2f
_struct_3I = None
def _get_struct_3I():
    global _struct_3I
    if _struct_3I is None:
        _struct_3I = struct.Struct("<3I")
    return _struct_3I
_struct_4I = None
def _get_struct_4I():
    global _struct_4I
    if _struct_4I is None:
        _struct_4I = struct.Struct("<4I")
    return _struct_4I
_struct_6f = None
def _get_struct_6f():
    global _struct_6f
    if _struct_6f is None:
        _struct_6f = struct.Struct("<6f")
    return _struct_6f
_struct_I3f = None
def _get_struct_I3f():
    global _struct_I3f
    if _struct_I3f is None:
        _struct_I3f = struct.Struct("<I3f")
    return _struct_I3f
_struct_If = None
def _get_struct_If():
    global _struct_If
    if _struct_If is None:
        _struct_If = struct.Struct("<If")
    return _struct_If
_struct_IfI = None
def _get_struct_IfI():
    global _struct_IfI
    if _struct_IfI is None:
        _struct_IfI = struct.Struct("<IfI")
    return _struct_IfI
_struct_f = None
def _get_struct_f():
    global _struct_f
    if _struct_f is None:
        _struct_f = struct.Struct("<f")
    return _struct_f
_struct_fB = None
def _get_struct_fB():
    global _struct_fB
    if _struct_fB is None:
        _struct_fB = struct.Struct("<fB")
    return _struct_fB
class ReadAllSequences(object):
  _type          = 'kortex_driver/ReadAllSequences'
  _md5sum = 'df3235fc6166f601431dc4bc8e55f776'
  _request_class  = ReadAllSequencesRequest
  _response_class = ReadAllSequencesResponse
